{"name":"Roguelike","tagline":"1GAM March 2014","body":"| Some things I worked on | Percent of overall project |\r\n|--------|---------|\r\n| 2D game mechanics | Moderate |\r\n\r\n| Tools and Resources| |\r\n|--------|---------|\r\n| [Unity 4.3](http://www.unity3d.com/) | Game Engine / Editor |\r\n| C# | Scripting Language |\r\n| Monodevelop | IDE |\r\n| [GIMP](http://www.gimp.org/) | Image Editor |\r\n\r\nFor OneGameAMonth March 2014, I decided to continue working in 2D and make a top-down view roguelike adventure game. I want to make this game big but for this month, I left it at a stripped-down version as I learn what I'm doing. In the coming months, I will expand upon this framework and make it into a proper game. As it is now, you can move around screen, pick up weapons and armor (and they get automatically equipped), and attack enemies. The level populates with a random set of four items and four enemies. You can then exit the level, which generates the level again. The game is turn-based in that things like enemy attacks or movement only occur when the player moves.\r\n\r\n## Personal Goal\r\nI really enjoy RPG games, so I want to build towards being able to make one. A simple roguelike will give me the foundation I need to build a larger RPG, I figure. An inventory system, items and their stats, player stats, enemies and their stats, and random generation of levels are all things a roguelike has that I need to know for making an RPG. So I set out to get some experience with all of them.\r\n\r\n## What I Learned\r\n### Technical\r\nI didn't make the mistake I did for January's game and set my sights too high. Nothing I worked on this month was too challenging as I set out to build only a framework of a game that I could build upon for several months. This month's tasks were nothing I was too unfamiliar with. But even then practice makes perfect, as I've been told. The level's data is stored as a 2D array. This was I can reference everything I need by looking at the correct position in the array without having to worry about calculating anything from the screen view. However, this could prove a problem if somehow this data layer and what's on screen get de-synchronized. I worry this was the wrong approach because of this, but it also makes the most sense to me, with my current knowledge anyway.\r\n\r\nThe randomly choosing of enemies and items is simply choosing a random prefab which holds the sprite and default damage and health of the item or enemy. This was my first time using Resources.Load, so I guess I learned about that this month.\r\n\r\nThis month, I continued work on the debug output class I started last month. I simplified it so that I no longer have to keep track of Dictionary keys. It uses a List that gets cleared at the end of every frame (after OnGUI gets called). And then I complicated it by allowing different output to each corner of the screen. The top two corners get updated every frame and are useful for outputting things that change every frame, like a coordinate. The bottom two corners each use different Queues that are used like a log of events. This is similar to the regular Debug.Log available in Unity. But now I can see this on screen. These Queues don't get emptied and re-populated every frame obviously. They are meant to be called in a non-Update method. Once the queue reaches its capacity (settable by the user), the first item is de-queued and the new message is added on top. I ended up using this system to display my combat log and player stats. This is an inefficient way of doing so and was only used for the testing of the early framework of a game. But it works well for what I needed.\r\n\r\n### Challenges\r\nThe biggest challenge I had this month was getting the enemies to chase the player when he got near to them. While I was never really stuck on any of it, it did take a while to work through the mechanics in my head and in code. Every time the player moves, the game manager checks a radius around the player to see what is near. If it is an enemy, the  distance calculation is performed. The enemy then moves in the direction it is furthest from the player in. For example, if the player is to the northeast - 2 spaces to the north and 1 space east, the enemy will move north first. In the case that the player is equi-distant in two directions (one tile north and one east), a random choice is made. The short-lived problem that I ran into was getting the enemy to attack once he was adjacent in one of the four cardinal directions. This wasn't a technical challenge as it's a simple check. It was an issue only because I was changing things a lot and this mechanic seemed to be the one that suffered because of it. In the end, I got it working though.\r\n\r\n## What I Would Change\r\nI wouldn't change much in this. There may be better or more efficient ways of doing things, but my primary focus will be finishing this game in the coming months. Coming back to this project will allow me to fix anything that needs to be changed for future usability.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}